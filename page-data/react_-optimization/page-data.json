{"componentChunkName":"component---node-modules-gatsby-theme-portfolio-minimal-src-templates-article-index-tsx","path":"/react_-optimization/","result":{"pageContext":{"article":{"banner":null,"body":"<h1>성능 최적화</h1>\n<h2>Rerendering 방지</h2>\n<p>컴포넌트 리렌더링 되는 조건은</p>\n<ol>\n<li>전달받은 props가 변경될 때</li>\n<li>부모 컴포넌트가 리렌더링 될 때</li>\n<li>자신의 state가 변경될 때</li>\n</ol>\n<p>이다.</p>\n<h3>useMemo</h3>\n<p>컴포넌트가 리렌더링 될 때마다 함수도 리렌더링 되는데, 리렌더링할 때마다 실행 시간이 오래 걸리는 함수를 연산된 값을 <code class=\"language-text\">useMemo</code>라는 Hook 을 사용하여 재사용할 수 있다.</p>\n<p>⇒ memoization : 기존에 수행한 연산의 결과값을 어딘가에 저장해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법. memoization을 절적히 적용하면 중복 연산을 피할 수 있기 때문에 메모리를 조금 더 쓰더라도 애플리케이션의 성능을 최적화할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> memoizedValue <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">computeExpensiveValue</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">useMemo</code>는 의존성이 변경되었을 때에만 메모이제이션된 값만 다시 계산한다.</p>\n<p>단, useMemo를 남용하면 단점이 있다.</p>\n<ol>\n<li>컴포넌트의 복잡도가 올라가 코드 가독성이 떨어지고, 따라서 유지보수가 어려워진다.</li>\n<li>useMemo가 적용된 레퍼런스는 재활용을 위해 가비지 컬렉션에서 제외되기 때문에 메모리를 더 쓴다.</li>\n</ol>\n<h3>React.memo 컴포넌트 메모이제이션</h3>\n<p>useMemo와 달리 hook이 아니므로 클래스 컴포넌트에도 적용이 가능하다.</p>\n<p>컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정하여 함수형 컴포넌트의 리렌더링 성능을 최적화한다.</p>\n<p>React.memo는 콜백함수를 이용해 메모이제이션을 적용할지 여부를 판단할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> MyComponent <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">MyComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* props를 사용하여 렌더링 */</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>useCallback</h3>\n<p>useMemo가 리턴되는 값을 memoize 시켜주었는데, useMemo와 비슷한 useCallback은 함수 선언을 memoize 하는데 사용된다.</p>\n<p>자식 컴포넌트에 함수를 넘겨줄 때 새로 생성된 함수를 넘겨주면, 자식 컴포넌트를 React.memo로 감쌌어도 전달된 함수 props이 다른 참조 값을 가지므로 props가 변경된 것으로 인식하고 리렌더링을 한다. 이를 방지하기 위해 useCallback을 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> memoizedCallback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3><strong>자식 컴포넌트의 props로 객체를 넘겨줄 경우 변형 X</strong></h3>\n<p>자식 컴포넌트의 props로 전달할 때 형태에 주의해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// 생성자 함수</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Component</span></span> <span class=\"token attr-name\">prop</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Obj</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token comment\">// 객체 리터럴</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Component</span></span> <span class=\"token attr-name\">prop</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>property<span class=\"token operator\">:</span> <span class=\"token string\">\"x\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>새로 생성된 객체가 props로 들어가므로 컴포넌트가 리렌더링 될 때마다 새로운 객체가 생성되어 자식 컴포넌트로 전달된다.</p>\n<p>생성자 함수나 객체 리터럴로 객체를 생성해서 하위 컴포넌트로 넘겨주는 방식이 아닌, state를 그대로 하위컴포넌트에 넘겨주어 필요한 데이터 가공을 그 하위컴포넌트에서 해주는 것이 좋다.</p>\n<h3>key 값에 index 사용 X</h3>\n<p>어떤 배열에 중간에 어떤 요소가 삽입될때 그 중간 이후에 위치한 요소들은 전부 index가 변경된다.</p>\n<p>그러면 key 값이 변경되면서 React는 key가 동일 할 경우, 동일한 DOM Element를 보여주기 때문에 예상치 못한 문제가 발생할 수 있다.</p>","categories":["Study","React"],"date":"June 06, 2023","description":"리액트 최적화 방법","id":"c96a98d1-acf8-5ec3-b8e2-6b7545c94254","keywords":["React"],"slug":"/react_-optimization/","title":"리액트 최적화","readingTime":{"text":"5 min read"}},"listingPagePath":"/blog"}},"staticQueryHashes":["3262260831","948380417"],"slicesMap":{}}